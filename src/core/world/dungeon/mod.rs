//!
//! Generate a super simple dungeon
//!

extern crate rand;
use self::rand::{thread_rng, Rng};

use core::object::Entity;

pub mod map;
use self::map::{Grid, Tile, TileType, FloorType, WallType, TrapType, Biome, spawnable};

// Privately use automata
mod automata;
use self::automata::{Automaton, DrunkardsWalk};

// Privately use builders
mod builder;
use self::builder::{Buildable, Fussy, Simple, Structure};

mod dungeon_tests;

const GRASS_COLORS : [(u8, u8, u8); 3] = [
  (76, 74, 75),
  (76, 79, 75),
  (80, 74, 75)
];


///
/// `Dungeon` struct to stitch together all builders and cellular automatons
///
#[derive(Default, Clone)]
pub struct Dungeon {
  pub width: usize,
  pub height: usize,
  pub grid: Grid<Tile>,
}

impl Dungeon {

  ///
  /// Make the dungeon
  ///
  pub fn build(&mut self) {

    // The purpose of this function is to create some basic grid object, 
    // and completely fill it out into a dungeon.

    // Currently, it only builds on specific type of dungeon, and in the future,
    // there should be some construct to generate types of dungeons.

    // 'Types' here refers to dungeons with different themes, that have different terrain features -
    // think of branches in DCSS. Coupled with this, the Dungeon struct should hold onto this type and
    // the world should be able to access it to generate items and monsters in the type/biome combinations
    // that will appear

    // We start with a basic grid object. We will pass references of this object into various functions to carve out a dungeon.
    let mut grid : Grid<Tile>;

    // Fill the map with walls first
    grid = Dungeon::generate_grid(self.width, self.height, Tile::new(
      "Wall",
      ' ',
      (40, 40, 40),
      (33, 33, 33),
      TileType::Wall(WallType::Normal))
    );

    // Apply simple builder. This creates a simple corridor/room dungeon based off the simple builder
    // Note how the grid is being consumed to replace itself here, but we don't want this later on.
    grid = Simple::new(grid).build();

    // Create several reusable constructs for walls and floors. Since passing these directly into functions
    // will cause the references to be lost, clone them first, since Tile derives Clone.
    let wall = Tile::new(
      "Wall",
      ' ',
      (40, 40, 40),
      (33, 33, 33),
      TileType::Wall(WallType::Normal)
    );

    let floor = Tile::new(
      "Floor",
      ' ',
      (27, 27, 27),
      (20, 20, 20),
      TileType::Floor(FloorType::Normal)
    );

    // Closure for generating drunkards walks. Basically just makes the process of adding these
    // easy. And since we don't use it anywhere else, it doesn't really make sense to turn it into a function,
    // though it may be in the future.
    
    // This is geared towards eating walls and replacing them with floors, so mainly just to flesh out the dungeon.
    let drunk = |chaos: f32, iter: u32, grid: &mut Grid<Tile> | -> Grid<Tile> {
      let d = DrunkardsWalk::new(chaos);
      d.generate(
        grid,
        None,
        None,
        Some(wall.clone()),
        floor.clone(),
        iter
      )
    };

    // Make three passes of this basic walk to carve caves.

    // Total randomness - Really centralized areas that are mostly opened since it walks over itself a lot
    grid = drunk(1.0, 1000, &mut grid);

    // Semi random - A mixture of the previous and next option
    grid = drunk(0.5, 1000, &mut grid);

    // Mostly orderly - Long corridors that occassionally deviate
    grid = drunk(0.25, 1000, &mut grid);

    // Add structures
    grid = Structure::new(grid).build();

    // Biome generation

    // Mostly just a proof of concept. Biomes are generated by comparing noise maps to the grid then flipping biomes

    // Apply noise for Cave biome
    let mut f1 = Fussy::new(Dungeon::generate_grid(self.width, self.height, 0_u8), 1.2);
    let bin_grid1 = f1.build();

    // Iterate over the grid
    for x in 0..self.width {
      for y in 0..self.height {
        // Positions of 1 mean that the noise passes the threshold
        if bin_grid1[x][y] == 1 {
          // First flip the biome
          grid[x][y].biome = Biome::Cave;
          // Then recolor based on tile type
          match grid[x][y].tiletype {
            TileType::Wall(_) => {
               grid[x][y].set_fg((67, 57, 57));
               grid[x][y].set_bg((60, 50, 50));
            },
            TileType::UpStair | TileType::DownStair | TileType::TallGrass => {
              grid[x][y].set_bg((25, 20, 20));
            },
            _ => {
              grid[x][y].set_fg((32, 27, 27));
              grid[x][y].set_bg((25, 20, 20));
            }
          }
        }
      }
    }

    // Apply noise for Crypt biome
    let mut f2 = Fussy::new(Dungeon::generate_grid(self.width, self.height, 0_u8), 1.2);
    let bin_grid2 = f2.build();

    for x in 0..self.width {
      for y in 0..self.height {
        if bin_grid2[x][y] == 1 {
          grid[x][y].biome = Biome::Crypt;
          match grid[x][y].tiletype {
            TileType::Wall(_) => {
               grid[x][y].set_fg((57, 57, 57));
               grid[x][y].set_bg((50, 50, 50));
            },
            TileType::UpStair | TileType::DownStair | TileType::TallGrass => {
              grid[x][y].set_bg((20, 20, 20));
            }
            _ => {
              grid[x][y].set_fg((27, 27, 27));
              grid[x][y].set_bg((20, 20, 20));
            }
          }
        }
      }
    }

    // Apply noise for Sunken biome
    let mut f3 = Fussy::new(Dungeon::generate_grid(self.width, self.height, 0_u8), 1.4);
    let bin_grid3 = f3.build();

    for x in 0..self.width {
      for y in 0..self.height {
        if bin_grid3[x][y] == 1 {
          grid[x][y].biome = Biome::Sunken;
          match grid[x][y].tiletype {
            TileType::Wall(_) => {
              grid[x][y].set_fg((57, 57, 67));
              grid[x][y].set_bg((50, 50, 60));
            },
            TileType::UpStair | TileType::DownStair | TileType::TallGrass => {
              grid[x][y].set_bg((20, 20, 25));
            }
            _ => {
              grid[x][y].set_fg((27, 27, 32));
              grid[x][y].set_bg((20, 20, 25));
            }
          }
        }
      }
    }

    // Apply noise for water
    let mut f4 = Fussy::new(Dungeon::generate_grid(self.width, self.height, 0_u8), 1.4);
    let bin_grid4 = f4.build();

    for x in 0..self.width {
      for y in 0..self.height {
        if bin_grid4[x][y] == 1 {
          match grid[x][y].tiletype {
            TileType::Wall(_) | TileType::DownStair | TileType::UpStair => {},
            _ => {
              grid[x][y].set_bg((57, 144, 255));
              grid[x][y].tiletype = TileType::Water;
            }
          }
        }
      }
    }

    // Apply noise for crystal biome
    let mut f5 = Fussy::new(Dungeon::generate_grid(self.width, self.height, 0_u8), 1.67);
    let bin_grid5 = f5.build();

    for x in 0..self.width {
      for y in 0..self.height {
        if bin_grid5[x][y] == 1 {
          match grid[x][y].tiletype {
            TileType::Floor(_) => {
              grid[x][y] = Tile::new(
                "Crystaline Floor", 
                ' ', 
                (0, 0, 0), 
                (183, 141, 212), 
                TileType::Floor(FloorType::Crystal)
              );
            },
            TileType::Wall(_) => {
              grid[x][y] = Tile::new(
                "Crystaline Wall", 
                ' ', 
                (0, 0, 0), 
                (216, 197, 244), 
                TileType::Wall(WallType::Crystal)
              );
            }
            _ => {}
          }
        }
      }
    }

    // Apply noise for tall grass
    let mut f6 = Fussy::new(Dungeon::generate_grid(self.width, self.height, 0_u8), 1.5);
    let bin_grid6 = f6.build();

    for x in 0..self.width {
      for y in 0..self.height {
        if bin_grid6[x][y] == 1 {
          match grid[x][y].tiletype {
            TileType::Floor(_) => {
              grid[x][y] = Tile::new(
                "Tall Grass", 
                '"', 
                *rand::thread_rng().choose(&GRASS_COLORS).unwrap(), 
                (grid[x][y].get_bg().0, grid[x][y].get_bg().1, grid[x][y].get_bg().2), 
                TileType::TallGrass
              );
            },
            _ => {}
          }
        }
      }
    }

    // Add pretty details last.

    // Add some hard walls
    for x in 0..self.width {
      for y in 0..self.height {
        // Basically just select 30% of walls to be 'hard walls' which are no different from normal walls
        if grid[x][y].tiletype == TileType::Wall(WallType::Normal) {
          let mut rng = thread_rng();
          let chance = rng.gen_range(1, 100);
          if chance > 70 {
            grid[x][y].glyph = '#';
            grid[x][y].tiletype = TileType::Wall(WallType::Hard);
          }
        }
      }
    }

    // Add floor features
    for x in 0..self.width {
      for y in 0..self.height {
        if grid[x][y].tiletype == TileType::Floor(FloorType::Normal) {
          let mut rng = thread_rng();
          let feature_chance = rng.gen_range(1, 100);

          // Create basic rock features
          if feature_chance > 90 {
            let feature = rng.gen_range(1, 5);
            match feature {
              1 => grid[x][y].glyph = ',',
              2 => grid[x][y].glyph = '.',
              3 => grid[x][y].glyph = '%',
              4 => grid[x][y].glyph = '*',
              _ => {}
            };

            // Add foliage in specific biomes
            match grid[x][y].biome {
              Biome::Cave => {
                let foliage_chance = rng.gen_range(1, 100);
                match foliage_chance {
                  1...5 => grid[x][y].set_fg((76, 74, 45)),
                  6...10 => grid[x][y].set_fg((35, 30, 30)),
                  11...15 => grid[x][y].set_fg((76, 74, 45)),
                  16...20 => grid[x][y].set_fg((76, 74, 45)),
                  _ => {}
                };
              }
              _ => {}
            };
            
          }
        }
      }
    }

    // Add Stairs

    // So I know that get_valid_location() should be deprecated since we started adding stairs
    // but we're just gonna have to live with it for now
    
    // Stair location
    let dspos = Dungeon::get_valid_location(&grid);
    // Get the background color of the tile that it will be going on top of
    let dsbgcol = grid[dspos.0][dspos.1].get_bg();
    // Replace grid tile with stair tile
    grid[dspos.0][dspos.1] = Tile::new(
      "Down Stair",
      '>',
      (255, 255, 255),
      (dsbgcol.0, dsbgcol.1, dsbgcol.2),
      TileType::DownStair
    );

    // Repeat above process
    let uspos = Dungeon::get_valid_location(&grid);
    let usbgcol = grid[uspos.0][uspos.1].get_bg();
    grid[uspos.0][uspos.1] = Tile::new(
      "Up Stair",
      '<',
      (255, 255, 255),
      (usbgcol.0, usbgcol.1, usbgcol.2),
      TileType::UpStair
    );

    // Add a trap

    let tpos = Dungeon::get_valid_location(&grid);
    let tbgcol = grid[tpos.0][tpos.1].get_bg();
    grid[tpos.0][tpos.1] = Tile::new(
      "Memory Loss Trap", 
      '^', 
      (255, 255, 0), 
      (tbgcol.0, tbgcol.1, tbgcol.2), 
      TileType::Trap(TrapType::MemoryLoss)
    );

    // Spent 300 million years wondering why the map was all walls until I realized this CRUCIAL piece of code
    // suddenly vanished.
    // Don't delete.
    self.grid = grid;

  }

  fn generate_grid<T : Clone>(w: usize, h: usize, init: T) -> Grid<T> {
    // Make grid
    let mut grid = Grid::<T>::new();

    // Fill it with Vecs
    for _x in 0..w {

      // Fill new vecs with init
      let mut vec = Vec::<T>::new();

      for _y in 0..h {
        vec.push(init.clone());
      }

      grid.push(vec);

    }

    return grid;

  }

  ///
  /// Get the player's starting location as a `Pos`
  ///
  /// NOTE: Should be deprecated and removed once stairs show up
  ///
  pub fn get_valid_location(grid: &Grid<Tile>) -> (usize, usize) {
    loop {
      let mut rng = thread_rng();
      let x : usize = rng.gen_range(1, grid.len() - 2);
      let y : usize = rng.gen_range(1, grid[0].len() - 2);

      if spawnable(&grid[x][y]) {
        return (x, y);
      }

    }
  }

  ///
  /// Return a new `Dungeon` that consists of pure walls
  ///
  pub fn new(map_dim: (usize, usize)) -> Dungeon {

    return Dungeon {
      width: map_dim.0,
      height: map_dim.1,
      grid: Grid::new()
    };

  }

}
